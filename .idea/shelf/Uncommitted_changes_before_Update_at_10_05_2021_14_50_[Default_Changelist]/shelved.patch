Index: pythonProject2/base_strat.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#***************************************************************************************#\r\n#               LSINF2275 - Data mining & Decision Making                               #\r\n#                       Project 2: BlackJack                                            #\r\n#                                                                                       #\r\n#   Authors :   BAILLY Gabriel                                                          #\r\n#               WAUTIER Lara                                                            #\r\n#               ZONE Corentin                                                           #\r\n#   Program :   DATS2M                                                                  #\r\n#                                                                                       #\r\n#   inspiration: https://www.askpython.com/python/examples/blackjack-game-using-python  #\r\n#                                                                                       #\r\n#***************************************************************************************#\r\n\r\n# import\r\nimport random\r\nimport os\r\nimport collections\r\n\r\n# Global variables\r\nimport numpy as np\r\n\r\nsuits = [\"Spades\", \"Hearts\", \"Clubs\", \"Diamonds\"]\r\nsuits_values = {\"Spades\": \"\\u2664\", \"Hearts\": \"\\u2661\", \"Clubs\": \"\\u2667\", \"Diamonds\": \"\\u2662\"}\r\ncards = [\"A\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\"]\r\ncards_values = {\"A\": 11, \"2\": 2, \"3\": 3, \"4\": 4, \"5\": 5, \"6\": 6, \"7\": 7, \"8\": 8, \"9\": 9, \"10\": 10, \"J\": 10, \"Q\": 10,\r\n                \"K\": 10}\r\nnb_deck = 4\r\nresult_split = []\r\nglobal split\r\n\r\nglobal capital\r\nhand1 = True\r\n\r\ndef cls():\r\n    os.system('cls')\r\n\r\nclass Card:\r\n    def __init__(self, suit, value, card_value):\r\n        self.suit = suit\r\n        self.value = value\r\n        self.card_value = card_value\r\n\r\n    def __str__(self):\r\n        return self.value + self.suit\r\n\r\n\r\ndef deck(nb_deck):\r\n    a = 0\r\n    deck = []\r\n    while (a < nb_deck):\r\n        for i in suits:\r\n            for j in cards:\r\n                deck.append(Card(suits_values[i], j, cards_values[j]))\r\n        a += 1\r\n    return deck\r\n\r\n\r\ndef hit(deck):\r\n    card = deck[0]\r\n    deck.remove(card)\r\n    return card\r\n\r\n\r\ndef game_decision(deck, player_cards, player_score,dealer_cards,opti_policy):\r\n    global split\r\n    global both_hand_loose\r\n    global capital\r\n    global mise, mise1, mise2\r\n    global hand1\r\n    ################################Enter the choice of the player################################\r\n    choice = \"BJ\"\r\n    while player_score < 21:\r\n\r\n        #random choice of the policy\r\n        choice = choice_policy(player_cards,dealer_cards,opti_policy)\r\n\r\n        # if hit\r\n        if choice.upper() == 'H':\r\n            card = hit(deck)\r\n            player_cards.append(card)\r\n            player_score += card.card_value\r\n\r\n            # if ace among card\r\n            c = 0\r\n            while player_score > 21 and c < len(player_cards):\r\n                if player_cards[c].card_value == 11:\r\n                    player_cards[c].card_value = 1\r\n                    player_score -= 10\r\n                    c += 1\r\n                else:\r\n                    c += 1\r\n\r\n        # if Stand\r\n        if choice.upper() == 'S':\r\n            break\r\n\r\n        # if Double, only one hit but the bet is doubled\r\n        if choice.upper() == 'D':\r\n            mise = mise * 2\r\n            card = hit(deck)\r\n            player_cards.append(card)\r\n            player_score += card.card_value\r\n\r\n            # if ace among card\r\n            c = 0\r\n            while player_score > 21 and c < len(player_cards):\r\n                if player_cards[c].card_value == 11:\r\n                    player_cards[c].card_value = 1\r\n                    player_score -= 10\r\n                    c += 1\r\n                else:\r\n                    c += 1\r\n\r\n            break\r\n\r\n\r\n    \"\"\"# Check if player has a Blackjack (only two card for blackjack, else the game continue)\r\n    if player_score == 21 and len(player_cards) == 2:\r\n        print(\"PLAYER HAS A BLACKJACK\")\r\n        quit(\"\"\"\r\n\r\n    # Check if player busts\r\n    if player_score > 21:\r\n        capital -= mise\r\n\r\n    return (player_cards, player_score,choice)\r\n\r\n\r\ndef game(deck,opti_policy):\r\n    global cards_values\r\n\r\n    player_cards = []\r\n    dealer_cards = []\r\n\r\n    player_score = 0\r\n    dealer_score = 0\r\n    global split\r\n    split = False\r\n    global both_hand_loose\r\n    global capital\r\n    global mise\r\n\r\n    ############dealing first two card to player and dealer################\r\n    while len(player_cards) < 2:\r\n\r\n        # dealing to player\r\n        card = hit(deck)\r\n        player_cards.append(card)\r\n        player_score += card.card_value\r\n\r\n        # if both first two card are Ace, the first Ace value = 1\r\n        if len(player_cards) == 2:\r\n            if player_cards[0].card_value == 11 and player_cards[1].card_value == 11:\r\n                player_cards[0].card_value = 1\r\n                player_score -= 10\r\n\r\n        # dealing to dealer\r\n        card = hit(deck)\r\n        dealer_cards.append(card)\r\n        dealer_score += card.card_value\r\n\r\n        # if both first two card are Ace, the first Ace value = 1\r\n        if len(dealer_cards) == 2:\r\n            if dealer_cards[0].card_value == 11 and dealer_cards[1].card_value == 11:\r\n                dealer_cards[1].card_value = 1\r\n                dealer_score -= 10\r\n\r\n    # Player gets a blackjack\r\n    if player_score == 21:\r\n        capital += 1.5 * mise\r\n        #\r\n        return (player_score,len(player_cards),dealer_cards[0].card_value,\"BJ\",1.5*mise)\r\n\r\n    ############################game decision#############################\r\n    result = game_decision(deck, player_cards, player_score, dealer_cards, opti_policy)\r\n\r\n    player_cards = result[0]\r\n    player_score = result[1]\r\n    choice = result[2]\r\n\r\n    #if player loose\r\n    if player_score>21:\r\n        return (player_score-player_cards[-1].card_value,len(player_cards)-1,dealer_cards[0].card_value,choice,-mise)\r\n\r\n\r\n    #####################################dealer phase############################\r\n    while dealer_score < 17:\r\n        dealer_hit_card = hit(deck)\r\n        dealer_cards.append(dealer_hit_card)\r\n        dealer_score += dealer_hit_card.card_value\r\n\r\n        # case if Ace in hand\r\n        c = 0\r\n        while dealer_score > 21 and c < len(dealer_cards):\r\n            if dealer_cards[c].card_value == 11:\r\n                dealer_cards[c].card_value = 1\r\n                dealer_score -= 10\r\n                c += 1\r\n            else:\r\n                c += 1\r\n\r\n\r\n    ###############End game result###############\r\n    # Dealer busts\r\n    if dealer_score > 21:\r\n        capital += mise\r\n        #\r\n        if choice==\"S\":\r\n            return (player_score,len(player_cards),dealer_cards[0].card_value,choice,+mise)\r\n        else:\r\n            return (player_score - player_cards[-1].card_value, len(player_cards)-1, dealer_cards[0].card_value, choice, +mise)\r\n\r\n\r\n        # Dealer gets a blackjack\r\n    if dealer_score == 21 and len(dealer_cards) == 2:\r\n        capital -= mise\r\n        #\r\n        if choice == \"S\":\r\n            return (player_score, len(player_cards), dealer_cards[0].card_value, choice, -mise)\r\n        else:\r\n            return (\r\n            player_score - player_cards[-1].card_value, len(player_cards) - 1, dealer_cards[0].card_value, choice,\r\n            -mise)\r\n\r\n    # TIE Game\r\n    if dealer_score == player_score:\r\n        if choice == \"S\":\r\n            return (player_score, len(player_cards), dealer_cards[0].card_value, choice, 0)\r\n        else:\r\n            return ( player_score - player_cards[-1].card_value, len(player_cards) - 1, dealer_cards[0].card_value, choice,0)\r\n\r\n    # Player Wins\r\n    elif player_score > dealer_score:\r\n        capital += mise\r\n        if choice == \"S\":\r\n            return (player_score, len(player_cards), dealer_cards[0].card_value, choice, +mise)\r\n        else:\r\n            return (\r\n            player_score - player_cards[-1].card_value, len(player_cards) - 1, dealer_cards[0].card_value, choice,\r\n            +mise)\r\n\r\n        # Dealer Wins\r\n    else:\r\n        capital -= mise\r\n        if choice == \"S\":\r\n            return (player_score, len(player_cards), dealer_cards[0].card_value, choice, -mise)\r\n        else:\r\n            return (\r\n            player_score - player_cards[-1].card_value, len(player_cards) - 1, dealer_cards[0].card_value, choice,\r\n            -mise)\r\n\r\n\r\n\r\ndef monte_carlo(opti_policy):\r\n    deck_game = deck(6)\r\n    random.shuffle(deck_game)\r\n    global capital\r\n    global mise\r\n    capital = 10000000\r\n    out_capital = [capital]\r\n    result_hand=[]\r\n    per_win=[]\r\n    nb_win=0\r\n\r\n    #renforcement learning\r\n    Q_value={}\r\n    Rewards={}\r\n    for key, value in opti_policy.items():\r\n        key_Q = (key[0],key[1],value[0])\r\n        Q_value[key_Q] = value[1]\r\n        Rewards[key_Q] = [value[1]]\r\n\r\n    ite = 0\r\n    nb_ite = 10000\r\n\r\n\r\n    while capital > 0 and ite < nb_ite:\r\n        ite += 1\r\n        #suffle deck if not enough cards present\r\n        if len(deck_game)<=10:\r\n            deck_game = deck(6)\r\n            random.shuffle(deck_game)\r\n\r\n        mise = 1\r\n        #simule a game\r\n        output = game(deck_game,opti_policy)\r\n        result_hand.append(output)\r\n        G = output[4]\r\n        if output[3] == \"S\":\r\n            mystrat = 0\r\n        elif output[3] == \"H\":\r\n            mystrat = 1\r\n        elif output[3] == \"D\":\r\n            mystrat = 2\r\n        else:\r\n            mystrat = 3\r\n        key_dico = (output[0],output[2],mystrat)\r\n        if key_dico not in Rewards:\r\n            Rewards[key_dico] = [G]\r\n            Q_value[key_dico] = G\r\n        else:\r\n            Rewards[key_dico].append(G)\r\n            Q_value[key_dico] = round((1/len(Rewards[key_dico])) * sum(Rewards[key_dico]),5)\r\n\r\n        out_capital.append(capital)\r\n\r\n        if out_capital[ite-1] <= out_capital[ite]:\r\n            nb_win+=1\r\n        win = round((nb_win/ite),2)\r\n        per_win.append(win)\r\n\r\n    return [out_capital,result_hand,Q_value,per_win]\r\n\r\n\r\ndef choice_policy(player_cards,dealer_cards,optimal_policy):\r\n    player_score = 0\r\n    for i in player_cards:\r\n        player_score += i.card_value\r\n    situation_key = (player_score,dealer_cards[0].card_value)\r\n\r\n    if player_score<=8:\r\n        out = \"H\"\r\n\r\n    else:\r\n        if len(player_cards) == 2:\r\n            if situation_key in optimal_policy.keys():\r\n                out = np.random.choice([\"H\", \"S\", \"D\", optimal_policy[situation_key][0]], p=[0.07, 0.07, 0.07, 0.79])\r\n            else:\r\n                out = np.random.choice([\"H\", \"S\", \"D\"])\r\n        else:\r\n            if situation_key in optimal_policy.keys():\r\n                out = np.random.choice([\"H\", \"S\", optimal_policy[situation_key][0]], p=[0.1, 0.1, 0.8])\r\n            else:\r\n                out = np.random.choice([\"H\", \"S\"])\r\n\r\n    if out== 0:\r\n        out = \"S\"\r\n    elif out== 1:\r\n        out == \"H\"\r\n    elif out == 2:\r\n        out == \"D\"\r\n\r\n    return out\r\n\r\n\r\ndef create_opti_policy(Q_value_sorted):\r\n    opti_policy={}\r\n    for key, value in Q_value_sorted.items():\r\n        if key[0]>=9 and key[1]!=1:\r\n            key_opti = (key[0], key[1])\r\n            if key_opti not in opti_policy:\r\n                opti_policy[key_opti] = (key[2], value)\r\n            else:\r\n                if opti_policy[key_opti][1] < value:\r\n                    opti_policy[key_opti] = (key[2], value)\r\n    return opti_policy\r\n\r\n\r\ndef simulation():\r\n    opti_policy={}\r\n    out=[]\r\n    for i in range(50):\r\n        myresult = monte_carlo(opti_policy)\r\n        Q_value_sorted = collections.OrderedDict(sorted(myresult[2].items()))\r\n        capital = myresult[0]\r\n        per_win = myresult[3]\r\n        opti_policy=create_opti_policy(Q_value_sorted)\r\n\r\n        out.append([opti_policy,capital, per_win])\r\n\r\n    return out\r\n\r\nresult = simulation()\r\n#print(\"PERCENTAGE WIN: \"+str(result[0][2]))\r\nprint(result[0][0])\r\n#print(\"PERCENTAGE WIN: \"+str(result[1][2]))\r\nprint(result[1][0])\r\n#print(\"PERCENTAGE WIN: \"+str(result[-1][2]))\r\nprint(result[-1][0])
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pythonProject2/base_strat.py b/pythonProject2/base_strat.py
--- a/pythonProject2/base_strat.py	(revision 421fa1944ffd6cdc56c801afa1028a5d30de3744)
+++ b/pythonProject2/base_strat.py	(date 1620504394947)
@@ -359,7 +359,7 @@
 def simulation():
     opti_policy={}
     out=[]
-    for i in range(50):
+    for i in range(5):
         myresult = monte_carlo(opti_policy)
         Q_value_sorted = collections.OrderedDict(sorted(myresult[2].items()))
         capital = myresult[0]
@@ -371,9 +371,9 @@
     return out
 
 result = simulation()
-#print("PERCENTAGE WIN: "+str(result[0][2]))
+print("PERCENTAGE WIN: "+str(result[0][2]))
 print(result[0][0])
-#print("PERCENTAGE WIN: "+str(result[1][2]))
+print("PERCENTAGE WIN: "+str(result[1][2]))
 print(result[1][0])
-#print("PERCENTAGE WIN: "+str(result[-1][2]))
+print("PERCENTAGE WIN: "+str(result[-1][2]))
 print(result[-1][0])
\ No newline at end of file
